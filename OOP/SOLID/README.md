# OOP 5원칙

1. SRP(Single Responsibility Principle) : 단일 책임 원칙
   클래스는 단 하나의 책임을 가져야 하며 클래스를 변경하는 이유는 단 하나의 이유이어야 한다.
2. OCP(Open-Closed Principle) : 개방-폐쇄 원칙
   확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.
3. LSP(Liskov Substitution Principle) : 리스코프 치환 원칙
   상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.
4. ISP(Interface Segregation Principle) : 인터페이스 분리 원칙
   인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.
5. DIP(Dependency Inversion Principle) : 의존 역전 원칙
   고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.

#### 

## SRP(Single Responsibility Principle) 단일 책임 원칙

한가지 기능만 제공해야 한다는 것은 클래스가 딱 한가지 메소드만 가지고 있어야 한다는 뜻은 아니다. SRP가 의미하는 것은 클래스는 클래스가 표현하는 해당 entity와 직접적 관련이 있는 기능만 제공해야 한다는 것이다. 편의를 위해서나 유사해서 entity와 굳이 직접적 관련이 없는 기능을 넣으면 안된다는 의미로 해석해야 한다. 즉 클래스는 한가지 "책임"만 져야 하다는 뜻이다.

책임이란 기준이 모호하기 때문에 **변경**을 책임의 기준으로 삼으면 설계에 용이할 수 있다.

**변경사항이 있을때, 애플리케이션의 파급 효과가 적으면** SRP 원칙을 잘 따른것으로 볼 수 있다.

Class의 코드가 변경될 이유는 단 한가지여야 한다.

User 클래스를 예를 들면, 유저 관련 로직이 바뀌어야 할때만 User 클래스가 바뀌어야 한다는 것이다. User 와 직접적으로 연결되어 있지않은 Order 관련 로직이 변경되었을때도 User 클래스의 수정이 필요하면 안된다는 것이 SRP의 핵심이다.



## OCP(Open-Closed Principle) 개방-폐쇄 원칙

OCP, Open-Closed Principle 규칙에 의하면 클래스는 수정할 이유는 최소화가 되어야 하지만(closed for modification) 확장성은 열려있어야 한다(open for extention). 뜻이 어려울 수 있지만 OCP의 핵심은 수정 없이 확장이 가능하게 하자는 것이다. 그리고 대부분의 경우 수정없이 확장이 가능하려면, 변경될 수 있는 부분은 hard-coding 하지 말아야 한다.

토비의 스프링이라는 책에서는 개방 폐쇄 원칙을 **높은 응집도와 낮은 결합도** 라는 원리로 설명할 수 있다.

**높은 응집도**

응집도가 높다는건 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있다는 뜻이다. 같은 책임, 관심사를 기반으로 하나의 객체로 설계하기 때문에 객체에 변경이 발생하더라도 다른 곳에 미치는 영향이 제한적이다.

**낮은 결합도**

책임과 관심사가 다른 객체 또는 모듈과는 낮은 결합도를 유지해야 한다. 이는 높은 응집도보다 더 민감한 원칙이라고 토비의 스프링에서는 설명하고 있다.

결합도란 하나의 오브젝트가 변경이 일어날때 관계를 맺고있는 다른 오브젝트에게 변화를 요구하는 정도로 설명한다.

즉 낮은 결합도란, 하나의 변경이 발생할 때 다른 모듈과 객체로 변경에 대한 요구가 전파되지 않는 상태라고 할 수 있다.



**확장에 열려있다?**

모듈의 확장성을 보장하는 것을 의미한다. 새로운 변경사항이 발생했을 때 유연하게 코드를 추가 또는 수정할 수 있기 때문이라고 한다.

**변경에 닫혀있다?**

객체를 직접적으로 수정하는건 제한해야 한다. 기능이 추가되거나 수정할 때, 객체를 직접적으로 수정해야 한다면 새로운 변경사항에 대해 유연하게 대응할 수 없는 애플리케이션이다.

이는 유지보수의 비용증가가 될 수 있으며, 객체지향적인 설계로 볼 수 없다.

따라서 객체를 직접 수정하지 않고도 변경사항을 적용할 수 있도록 설계해야 한다.



결과적으로 OCP는 추상화를 의미하는 것으로 해석된다. 객체를 추상화함으로써 확장엔 열려있고, 변경엔 닫혀있는 유연한 구조를 만들수 있는 것이다.



**추상화(Abstraciton)**

- 공통의 속성이나 기능을 묶어 이름을 붙이는 것

- 객체 지향적 관점에서 클래스를 정의하는 것을 바로 추상화라고 정의 내릴 수 있겠다.

- 좀 더 살펴보면 물고기, 사자, 토끼, 뱀이 있을 때 우리는 이것들을 각각의 객체라 하며 이 객체들을 하나로 묶으려 할 때, 만약 동물 또는 생물이라는 어떤 추상적인 객체로 크게 정의한다고 하자. 이때 동물 또는 생물이라고 묶는 것을 추상화 라고 한다.



## LSP(Liskov Substitution Principle) 리스코프 치환 원칙

객체는 프로그램의 정확성을 깨지 않으면서 하위 타입의 인스턴스로 바꿀수 있어야 한다.

리스코프 치환 원칙은 **"상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다."**를 의미한다.

이를 쉽게 말하면, **특정 메소드가 상위 타입을 인자로 사용한다고 할 때, 그 타입의 하위 타입도 문제 없이 정상적으로 작동을 해야 한다**는 것이다.

하위 클래스는 인터페이스 규약을 지켜서 작성되어야 한다. 다형성을 지원하기 위한 원칙, 인터페이스를 구현한 구현체를 믿고 사용하려면 LSP가 필요하다.

인터페이스의 메소드를 사용한다고 하면, 어떤 구현체를 사용하든 호출부에서 기대하는대로 동작되어야 한다는 것이다.



## ISP(Interface Segregation Principle) 인터페이스 분리 원칙

인터페이스 분리 원칙은 **"클라이언트는 자신이 사용하는 메소드에만 의존해야 한다."**를 의미한다.

이를 쉽게 표현하면, **"인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다."**라고 바꿔 말할 수 있다.

범용 인터페이스 하나보다는 특정 클라이언트를 위한 여러 개의 인터페이스 분리가 더 좋다.

`운전자가 자동차를 운전한다.` 라는 명제를 객체간 관계로 비유하면 자동차에 대한 인터페이스, 운전자에 대한 인터페이스를 각각 분리하는 것이다.

그럼 `운전자`는 `택시 기사`가 될수도 있고, `우버 드라이버`가 될수 있다. `자동차`는 `버스`가 될 수도 있고, `택시`가 될수도 있고, `스포츠카`가 될 수도 있다. 확장성이 커지는 셈이다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fblsa6C%2FbtqZUVLDy0z%2FyAW8iMv6jzCL9kZkCfdsEk%2Fimg.png)

위 구조는 인터페이스 분리 원칙을 위반한 예시이다. User1은 op1, User2는 op2, User3는 op3를 사용한다고 가정했을때, User1의 소스 코드는 op2와 op3를 사용하지 않음에도 이것들에 의존하며, op2의 소스 코드가 변경된다면 User1을 재컴파일하여 배포해야 한다는 문제가 있다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbzEMJy%2FbtqZSuA1Dz0%2FXYH3xsm7jOizUUhZTqIJb1%2Fimg.png)

OPS를 상속받는 U1Ops, U2Ops, U3Ops로 분리한다음, 적합한 클라이언트가 각각의 메소드를 사용할 수 있도록 변경해야 한다.



## DIP(Dependency Inversion Principle) 의존 역전 원칙

DIP 규칙에 따르면 클래스는 가능한 추상적으로 의존해야 하며 구체적으로 의존하면 안된다는 것이다. 클래스가 의존하는 외부 요소가 있다면 의존하는 요소가 수정되거나 변경되어도 해당 클래스는 수정하지 않아도 되도록 하라는 의미이다.

연극을 예로 들면 **배역(인터페이스)**과 **배우(구현체)**를 예로 들 수 있다. 이 때 연극은 특정 배우를 염두에 두고 기획되기보다 배역에 집중해서 기획되어야 한다.

특정 배우에 의존했는데 만약 그 배우가 스케줄 또는 당일 컨디션때문에 연극에 출연이 불발 될 경우 해당 연극은 차질이 불가피해진다. 따라서 연극은 배우가 아닌 배역에 의존해야 한다.

![](https://user-images.githubusercontent.com/33862991/114132424-4dab6680-993f-11eb-836d-39dbfdd59f94.png)

이렇게 의존관계를 설계하면 `LottoNumberGenerator` 객체에 대한 변경사항이 발생하거나 혹은 객체를 삭제할 일이 있어도 `Lotto` 클래스에는 직접적인 변경을 할 필요가 없게된다.