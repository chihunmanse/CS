# 데이터베이스

- RDBMS 설명

  - **답변**

    **RDBMS는 관계형 데이터베이스 내에 접근하여 데이터를 생성하고 관리할 수 있도록 도와주는 시스템입니다. RDB는 모든 데이터를 2차원 테이블 형태로 표현하는 데이터베이스로, row와 column으로 이루어진 테이블이 다른 테이블들과 외래 키로 관계를 맺고 모여있는 집합체로 이해할 수 있습니다.**

  - **DBMS란?**

    DBMS는 DataBase Management System의 약자로 사용자와 데이터베이스 사이에서 사용자의 요구에 따라 정보를 생성해 주고 데이터베이스를 관리해주는 소프트웨어

  - **RDB란?**

    Relational DataBase의 약자로 관계형 데이터 모델을 기초로 두고 모든 데이터를 2차원 테이블 형태로 표현하는 데이터베이스이다. 테이블이 다른 테이블들과 관계를 맺고 모여있는 집합체로 이해할 수 있다.

  - **RDBMS란?**

    관계형 데이터베이스 내에 접근하여 데이터를 생성하고 관리할 수 있도록 도와주는 시스템

    RDBMS는 Relational DataBase Management System의 약자로 관계형 모델을 기반으로 하는 DBMS 유형이다.

    관계형 데이터베이스(RDMBS)에서는 이러한 관계를 나타내기 위해 외래 키(foreign key)라는 것을 사용한다. 테이블은 row(행)와 column(칼럼)으로 이루어진 기본 데이터 저장 단위이다.

    이러한 테이블간의 관계에서 외래 키를 이용한 테이블 간 Join이 가능하다는 게 RDBMS의 가장 큰 특징이다.

  - 관계형 모델이란?

    관계형 모델은 실제 세계의 데이터를 '관계' 라는 개념을 사용해서 표현한 데이터 모델이다.

- SQL과 noSQL의 차이를 설명

  - **답변**

    RDBMS(SQL)는 정해진 스키마에 따라 데이터를 저장하여야 하므로 명확한 데이터 구조를 보장합니다. 또 관계에 따라 테이블들을 정규화시키기 때문에 데이터를 중복없이 저장할 수 있습니다.

    하지만 시스템이 커질 경우 JOIN문이 많은 복잡한 쿼리를 수행해야 합니다. 또 성능 향상을 위해 수직적 확장만 가능하기 때문에 서버 비용이 기하급수적으로 늘어날 수 있고 데이터 구조가 변경될 경우 관계된 다른 테이블들에 전반적으로 영향을 끼치기 때문에 데이터가 유연하지 못하다는 단점이 있습니다.

    NoSQL은 SQL과 반대로 스키마가 없기 때문에 유연하며 자유로운 데이터 구조를 가질 수 있고 수평적 확장을 지원하기 때문에 여러 서버에 데이터를 분산할 수 있습니다. 따라서 막대한 양의 데이터를 다루고 읽기와 쓰기 처리량이 큰 서비스의 경우에 적합합니다.

    하지만 데이터의 중복이 많이 발생할 수 있기 때문에 중복된 데이터가 변경될 경우 모든 콜렉션에서 변경 작업을 수행해야 하기 때문에 수정이 잦은 서비스에서는 비효율적일 수 있습니다.

  - **RDBMS와 NoSQL의 장단점**

    **RDBMS**

    장점

    - RDBMS는 위에서 설명을 하였듯이 정해진 스키마에 따라 데이터를 저장하여야 하므로 명확한 데이터 구조를 보장하고 있습니다.
    - 또한 관계는 각 데이터를 중복없이 한 번만 저장할 수 있습니다.

    단점

    - 테이블 간 관계를 맺고 있어 시스템이 커질 경우 JOIN문이 많은 복잡한 쿼리가 만들어질 수 있습니다.
    - 성능 향상을 위해서는 서버의 성능을 향상 시켜야하는 Scale-up만을 지원합니다. 이로 인해 비용이 기하급수적으로 늘어날 수 있습니다.
    - 스키마로 인해 데이터가 유연하지 못합니다. 나중에 스키마가 변경 될 경우 번거롭고 어렵습니다.

    **NoSQL**

    장점

    - NoSQL에서는 스키마가 없기 때문에 유연하며 자유로운 데이터 구조를 가질 수 있습니다. 언제든 저장된 데이터를 조정하고 새로운 필드를 추가할 수 있습니다.
    - 데이터 분산이 용이하며 성능 향상을 위한 Saclue-up 뿐만이 아닌 Scale-out 또한 가능합니다.

    단점

    - 데이터 중복이 발생할 수 있으며 중복된 데이터가 변경 될 경우 수정을 모든 컬렉션에서 수행을 해야 합니다.
    - 스키마가 존재하지 않기에 명확한 데이터 구조를 보장하지 않습니다.

  - **언제 사용될까?**

    **RDBMS**는 데이터 구조가 명확하며 변경 될 여지가 없으며 명확한 스키마가 중요한 경우 사용하는 것이 좋습니다. 또한 중복된 데이터가 없어(데이터 무결성) 변경이 용이하기 때문에 관계를 맺고 있는 데이터가 자주 변경이 이루어지는 시스템에 적합합니다.

    **NoSQL**은 정확한 데이터 구조를 알 수 없고 데이터가 변경/확장이 될 수 있는 경우에 사용하는 것이 좋습니다. 또한 단점에서도 명확하듯이 데이터 중복이 발생할 수 있으며 중복된 데이터가 변경될 시에는 모든 컬렉션에서 수정을 해야 합니다. 이러한 특징들을 기반으로 Update가 많이 이루어지지 않는 시스템이 좋으며 또한 Scale-out이 가능하다는 장점을 활용해 막대한 데이터를 저장해야 해서 Database를 Scale-Out 해야 되는 시스템에 적합합니다.

    읽기(read)처리를 자주하지만, 데이터를 자주 변경하지 않는 경우 (즉, 한번의 변경으로 수십 개의 문서를 수정 할 필요가 없는 경우

  - **SQL**

    관계형 데이터베이스에는 핵심적인 두 가지 특징이 있다.

    - 데이터는 **정해진 데이터 스키마에 따라 테이블에 저장**된다.
    - 데이터는 **관계를 통해 여러 테이블에 분산**된다.

    데이터는 테이블에 레코드로 저장되는데, 각 테이블마다 명확하게 정의된 구조가 있다. 해당 구조는 필드의 이름과 데이터 유형으로 정의된다.

    따라서 **스키마를 준수하지 않은 레코드는 테이블에 추가할 수 없다.** 즉, 스키마를 수정하지 않는 이상은 정해진 구조에 맞는 레코드만 추가가 가능한 것이 관계형 데이터베이스의 특징 중 하나다.

    또한, 데이터의 중복을 피하기 위해 '관계'를 이용한다.

    https://t1.daumcdn.net/cfile/tistory/994D09355C937ECD2D

    하나의 테이블에서 중복 없이 하나의 데이터만을 관리하기 때문에 다른 테이블에서 부정확한 데이터를 다룰 위험이 없어지는 장점이 있다.

  - **NoSQL**

    말그대로 관계형 DB의 반대다.

    **스키마도 없고, 관계도 없다!**

    NoSQL에서는 레코드를 문서(documents)라고 부른다.

    여기서 SQL과 핵심적인 차이가 있는데, SQL은 정해진 스키마를 따르지 않으면 데이터 추가가 불가능했다. 하지만 NoSQL에서는 다른 구조의 데이터를 같은 컬렉션에 추가가 가능하다.

    문서(documents)는 Json과 비슷한 형태로 가지고 있다. 관계형 데이터베이스처럼 여러 테이블에 나누어담지 않고, 관련 데이터를 동일한 '컬렉션'에 넣는다.

    따라서 위 사진에 SQL에서 진행한 Orders, Users, Products 테이블로 나눈 것을 NoSQL에서는 Orders에 한꺼번에 포함해서 저장하게 된다.

    따라서 여러 테이블에 조인할 필요없이 이미 필요한 모든 것을 갖춘 문서를 작성하는 것이 NoSQL이다. (NoSQL에는 조인이라는 개념이 존재하지 않음)

    그러면 조인하고 싶을 때 NoSQL은 어떻게 할까?

    > 컬렉션을 통해 데이터를 복제하여 각 컬렉션 일부분에 속하는 데이터를 정확하게 산출하도록 한다.

    하지만 이러면 데이터가 중복되어 서로 영향을 줄 위험이 있다. 따라서 조인을 잘 사용하지 않고 자주 변경되지 않는 데이터일 때 NoSQL을 쓰면 상당히 효율적이다.

  - **확장 개념**

    두 데이터베이스를 비교할 때 중요한 Scaling 개념도 존재한다.

    데이터베이스 서버의 확장성은 '수직적' 확장과 '수평적' 확장으로 나누어진다.

    - 수직적 확장 : 단순히 데이터베이스 서버의 성능을 향상시키는 것 (ex. CPU 업그레이드)
    - 수평적 확장 : 더 많은 서버가 추가되고 데이터베이스가 전체적으로 분산됨을 의미 (하나의 데이터베이스에서 작동하지만 여러 호스트에서 작동)

    데이터 저장 방식으로 인해 SQL 데이터베이스는 일반적으로 수직적 확장만 지원함

    수평적 확장은 NoSQL 데이터베이스에서만 가능

    > NoSQL이란(Not Only SQL)의 약자로 말 그대도 위에서 설명한 RDB 형태의 관계형 데이터베이스가 아닌 다른 형태의 데이터 저장 기술을 의미하고 있습니다. 또한 NoSQL에서는 RDBMS와는 달리 테이블 간 관계를 정의하지 않습니다. 데이터 테이블은 그냥 하나의 테이블이며 테이블 간의 관계를 정의하지 않아 일반적으로 테이블 간 Join도 불가능합니다.

    > NoSQL은 점점 빅데이터의 등장으로 인해 데이터와 트래픽이 기하급수적으로 증가함에 따라 RDBMS에 단점인 성능을 향상시키기 위해서는 장비가 좋아야 하는 Scale-Up의 특징이 비용을 기하급수적으로 증가시키기 때문에 데이터 일관성은 포기하되 비용을 고려하여 여러 서버에 분산하여 저장하는 Scale-Out을 목표로 등장하였습니다.

    > NoSQL이라고 하면 가장 유명한 Document 기반의 MongoDB를 많이 떠올리지만 MongoDB는 NoSQL한 종류로 NoSQL은 하기와 같이 다양한 형태의 저장 기술을 지원하고 있습니다.

    > 이 다양한 형태의 저장기술은 RDBMS 스키마에 맞추어 데이터를 관리해야 된다는 한계를 극복하고 수평적 확장성(Scale-out)을 쉽게 할 수 있다는 장점을 가지고 있습니다.

  - **NoSQL 종류**

    1. Key-Value Database

    - Key-Value Database는 데이터가 Key와 Value의 쌍으로 저장된다. Key는 Value에 접근하기 위한 용도로 사용되며, 값은 어떠한 형태의 데이터라도 담을 수 있다. 심지어는 이미지나 비디오도 가능하다. 또한 간단한 API를 제공하는 만큼 질의의 속도가 굉장히 빠른 편이다.
    - 대표적인 NoSQL Key-Value Model로는 Redis, Riak, Amazon Dynamo DB 등이 있다.

    1. Document Database

    - Documnet Database 데이터는 Key와Document의 형태로 저장된다. Key-Value 모델과 다른 점이라면 Value가 계층적인 형태인 도큐먼트로 저장된다는 것이다. 객체지향에서의 객체와 유사하며, 이들은 하나의 단위로 취급되어 저장된다. 다시 말해 하나의 객체를 여러 개의 테이블에 나눠 저장할 필요가 없어진다는 뜻이다.
    - 주요한 특징으로는 객체-관계 매핑이 필요하지 않다. 객체를 Document의 형태로 바로 저장 가능하기 때문이다. 또한 검색에 최적화되어 있는데, 이는 Ket-Value 모델의 특징과 동일하다. 단점이라면 사용이 번거롭고 쿼리가 SQL과는 다르다는 점이다. 도큐먼트 모델에서는 질의의 결과가 JSON이나 xml 형태로 출력되기 때문에 그 사용 방법이 RDBMS에서의 질의 결과를 사용하는 방법과 다르다.
    - 대표적인 NoSQL Document Model로는 MongoDB, CouthDB 등이 있다.

    1. Wide Column Database

    - Column-family Model 기반의 Database이며 이전의 모델들이 Key-Value 값을 이용해 필드를 결정했다면, 특이하게도 이 모델은 키에서 필드를 결정한다. 키는 Row(키 값)와 Column-family, Column-name을 가진다. 연관된 데이터들은 같은 Column-family 안에 속해 있으며, 각자의 Column-name을 가진다. 관계형 모델로 설명하자면 어트리뷰트가 계층적인 구조를 가지고 있는 셈이다. 이렇게 저장된 데이터는 하나의 커다란 테이블로 표현이 가능하며, 질의는 Row, Column-family, Column-name을 통해 수행된다.
    - 대표적인 NoSQL Column-family Model로는 HBase, Hypertable 등이 있다.

    1. Graph Database

    - Graph Model Model에서는 데이터를 Node와 Edge, Property와 함께 그래프 구조를 사용하여 데이터를 표현하고 저장하는 Database입니다. 개체와 관계를 그래프 형태로 표현한 것이므로 관계형 모델이라고 할 수 있으며, 데이터 간의 관계가 탐색의 키일 경우에 적합하다. 페이스북이나 트위터 같은 소셜 네트워크에서(내 친구의 친구를 찾는 질의 등) 적합하고, 연관된 데이터를 추천해주는 추천 엔진이나 패턴 인식 등의 데이터베이스로도 적합하다.
    - 대표적인 NoSQL Graph Model로는 Neo4J가 있다.

- noSQL 사용하는 이유 및 사례 (MongoDB)

  - **답변**

    빅데이터의 등장으로 인해 데이터와 트래픽이 많아지는 상황에서 수직적 확장만 가능한 RDBMS를 사용할 때 장비에 대한 비용이 기하급수적으로 증가함에 따라, 데이터 일관성은 포기하되 비용을 고려하여 여러 대의 서버에 분산하여 저장하는 수평적 확장을 목표로 NoSQL이 등장하였습니다.

    NoSQL에서는 유연하며 자유로운 데이터를 가질 수 있고 수직적 확장 뿐만 아니라 수평적 확장이 가능하기 때문에 데이터 분산에 용이합니다.

    읽기 처리를 자주 하지만 데이터를 자주 변경하지 않는 경우나 막대한 양의 데이터를 다뤄서 수평적 확장을 해야하는 경우에 사용합니다.

  - 보충

    - NoSQL에서는 스키마가 없기 때문에 유연하며 자유로운 데이터 구조를 가질 수 있습니다. 언제든 저장된 데이터를 조정하고 새로운 필드를 추가할 수 있습니다.
    - 데이터 분산이 용이하며 성능 향상을 위한 Saclue-up 뿐만이 아닌 Scale-out 또한 가능합니다.
    - 정확한 데이터 요구사항을 알 수 없거나 관계를 맺고 있는 데이터가 자주 변경되는 경우
    - 읽기(read)처리를 자주하지만, 데이터를 자주 변경하지 않는 경우 (즉, 한번의 변경으로 수십 개의 문서를 수정 할 필요가 없는 경우)
    - 데이터베이스를 수평으로 확장해야 하는 경우 ( 즉, 막대한 양의 데이터를 다뤄야 하는 경우, 읽기/쓰기 처리량이 큰 경우)

- DB 모델링 시 고려하는 부분 & 모델링 과정 서술

  - **모델링 고려사항 답변**

    비즈니스(프로젝트) 프로세스를 이해하고 요구사항을 모두 반영한 모델링을 했는지 확인합니다.

    프로젝트에서 모델링에 직접 참여하지 않은 사람들 (프론트엔드나 기획자, 디자이너)도 모델을 이해할 수 있고 서로 의사소통할 수 있도록 간결하고 명확하게 표현된 모델링인지 확인합니다.

    정규화 과정을 거쳐서 데이터의 중복을 제거하고 모델의 독립성이 확보돼있는지 확인합니다.

    데이터베이스 구축시에 데이터 별로 적절한 데이터타입을 사용하였는지 확인합니다.

  - **모델링 과정 답변**

    먼저 비즈니스(프로젝트)의 프로세스를 분석하며 서비스의 기능 요구사항 및 필요할 데이터들을 정리합니다. 데이터들의 공통점을 찾고 간략화하는 추상화 단계를 거치며 개념적 모델링을 합니다. 이후 데이터의 관계들을 정의하며 식별자를 도출하는 논리적 모델링을 거칩니다. 이 때 정규화를 거치며 데이터의 중복을 제거함으로써 모델의 독립성을 확보합니다. 그리고 실제 데이터베이스를 생성하는 물리적 모델링을 진행합니다.

- 정규화 기준

  - **답변**

    정규화를 하는 목적은 기본적으로 데이터의 중복을 최소한으로 줄이기 위해서입니다. 데이터의 중복이 늘어나면 데이터를 삽입, 수정, 삭제할때 갱신 이상이 발생할 수 있습니다.

    제 1 정규형의 기준으로 한 열에는 원자적 값만을 포함해야하고 같은 데이터가 여러 열에 반복되지 말아야 합니다.

    제 2 정규형의 기준으로 부분적 함수 종속이 없는지 확인합니다. 예를 들어 주문상품 테이블에 주문번호와 상품번호로 이루어진 기본키가 있고 주문수량과 상품가격 칼럼이 있다고 했을 때, 주문수량은 주문번호와 상품번호 모두를 알아야만 알 수 있기 때문에 완전 종속된 관계이지만 상품가격은 상품번호만 알면 알 수 있기 때문에 부분 종속된 관계입니다. 이 경우 상품가격은 상품번호를 기본키로 갖는 테이블로 따로 정규화시켜야 합니다.

    제 3 정규형의 기준으로 식별자 이외의 속성 간에 종속관계가 존재하지 않는지 확인합니다. 만약 주문번호를 기본키로 갖는 테이블에 주문일자와 유저번호, 유저이름과 주소 칼럼이 있다고 했을 때 유저번호에 따라서 유저의 이름과 주소의 값이 바뀌므로 이름, 주소는 유저번호에 종속된 속성들이라고 할 수 있습니다. 이 경우 유저번호를 기본키로 갖고 이름, 주소를 속성으로 갖는 유저 테이블을 따로 분리하고 주문 테이블에는 유저번호만 갖고 오도록 해야합니다.

  - **정규화의 개념**

    정규화를 하는 목적은 한마디로 말하자면 **데이터의 중복을 최소한으로 줄이기 위해서**이다.

    데이터들간에 중복을 줄여야 하는 이유는 우리가 객체지향 프로그래밍에서 중복코드를 줄여야 하는 이유와 같은 맥락이라고 할 수 있다.

    코드의 변경이 생기면 중복된 부분을 모두 고쳐야한다는 문제점이 있는것과 같이, 중복 데이터가 존재하면 다음과 같은 여러가지 문제가 발생한다. (물론 기본적으로 중복 데이터가 존재하면 저장공간이 낭비되기 때문에 중복을 없애야 한다는 것은 너무나 당연하다.)

    **불필요한 데이터를 함께 삽입**하지 않으면 어떤 데이터를 삽입하는 것이 불가능하고 (삽입 이상),

    중복된 데이터 가운데 일부만 수정되어 **데이터의 불일치**가 발생할 수도 있고 (수정 이상),

    어떤 데이터를 삭제하면 **유용한 데이터도 함께 삭제**가 될 수도 있다 (삭제 이상).

    이렇게 데이터의 중복이 존재해 발생하는 문제를 통틀어서 **갱신 이상(Update Anomaly)**라고 한다.

  - **제 1 정규형 (1NF; First Normal Form)**

    1NF 의 규칙은 아래와 같다.

    ```
    1. 열은 원자적 값만을 포함해야 한다.
    2. 같은 데이터가 여러 열에 반복되지 말아야 한다.
    ```

    ![https://miro.medium.com/max/1400/1*nb86cYqttt4dvd7O4_6bbA.png](https://miro.medium.com/max/1400/1*nb86cYqttt4dvd7O4_6bbA.png)

    toy1은 1번 규칙, toy2는 2번 규칙을 위반했다.

    ![https://miro.medium.com/max/488/1*WBP629x4Gf_UnIMdg4p1lA.png](https://miro.medium.com/max/488/1*WBP629x4Gf_UnIMdg4p1lA.png)

    ![https://miro.medium.com/max/1082/1*wvKNoTy1oHxyIkAFKrqWEQ.png](https://miro.medium.com/max/1082/1*wvKNoTy1oHxyIkAFKrqWEQ.png)

  - **제 2 정규형 (2NF; Second Normal Form)**

    2NF 의 규칙은 다음과 같다.

    ```
    1. 제 1 정규형이어야 한다.
    2. 부분적 함수 의존이 없어야 한다.
    ```

    ![https://miro.medium.com/max/488/1*_9NLzLmjycTwY0njFBX1SQ.png](https://miro.medium.com/max/488/1*_9NLzLmjycTwY0njFBX1SQ.png)

    이 주문품목 엔티티는 위에서 제 1정규화를 진행한 결과로 나온 엔티티이다. 그러므로 제 1정규화의 기준은 충족시켰으나, 부분적인 함수 의존이 존재하기 때문에 제 2 정규화 기준에 만족하지 못했다.

    주문수량은 주문번호가 변경되어도, 품목코드가 변경되어도 변경이 되어야 하므로 두 개의 키에 대해서 모두 종속적인 관계를 가지지만,

    품목단가의 경우, **품목코드가 변경이 되면 변경이 되어야 하지만 주문번호가 바뀐다고 해도 변경될 이유는 없기 때문에** 여기서 부분적 함수 종속 관계가 발생하게 된다.

    부분적 함수 종속이 문제가 되는 이유 역시 데이터의 중복이 발생하기 때문이다. 생각해보면, 품목 코드가 같아도 주문번호가 다르면 동일한 품목단가 데이터는 중복되어서 나타나게 되기 때문이다.

    ![https://miro.medium.com/max/1400/1*TngmgqFPXRI7fGFRvTqQ5Q.png](https://miro.medium.com/max/1400/1*TngmgqFPXRI7fGFRvTqQ5Q.png)

    부분적 함수 종속 관계의 원인이 되는 품목 단가 속성을 부모 엔티티를 따로 생성해 분리하였다.

  - **제 3 정규형 (3NF; Third Normal Form)**

    일반적으로 개발할때는 인위적으로 만든 기본키가 있고, 합성키는 존재하지 않도록 테이블을 설계하는 경우가 대부분이므로 거의 모든 경우 제 2 정규형은 만족하게 된다.

    제 3 정규화 조건을 맞추는 것이 관건인데, 그 규칙부터 알아보자.

    ```
    1. 제 2 정규형이어야 한다.
    2. 이행적 함수 종속 관계가 존재하지 않아야 한다.
    ```

    2번규칙을 다른 말로 하면, **식별자 이외의 속성간에 종속 관계가 존재하면 안된다**라고 해도 이해하는 데에 어렵지 않을 것이다.

    제 3 정규화를 위반한 경우 역시 해결법은 동일하다. 그 원인이 되는 속성을 제거하여 다른 엔티티의 속성으로 빼는 것.

    ![https://miro.medium.com/max/488/1*w9xrTznfWT_Oxl8l5ndh8g.png](https://miro.medium.com/max/488/1*w9xrTznfWT_Oxl8l5ndh8g.png)

    기본키가 하나의 속성으로 이루어져 있으므로 제 2 정규형까지는 만족하지만, 고객번호가 달라지면 고객명, 고객주소가 달라지는 이행적 종속 관계가 존재하기 때문에 제 3 정규형은 만족하지 않는다.

    이에 대한 해결방법으로 **‘고객’** 이라는 부모 엔티티를 만들고 이행적 종속 관계와 연관된 속성들을 그 엔티티로 분리하면 된다.

    ![https://miro.medium.com/max/490/1*DrUBRhMP19o1wTsBpK3Wig.png](https://miro.medium.com/max/490/1*DrUBRhMP19o1wTsBpK3Wig.png)

- SQL 기본 문법 정리 

  - 기본 문법 정리

    ### 1. 테이블 생성

    books라는 이름을 가지고 있으며 id, title, writer, quantity의 컬럼을 가지고 있는 테이블을 생성해보자

    ```sql
    CREATE TABLE books
    	(id INTEGER PRIMARY KEY AUTOINCREMENT,
        	title TEXT,
        	writer TEXT,
        	released_year INTEGER);
    ```

    ### 2. 데이터 입력하기

    위에서 만든 books 테이블에 데이터를 입력하자.

    ```sql
    INSERT INTO books VALUES(1, "How to Write a Sentence: And How to Read One", "tanley Eugene Fish", 2012);
    INSERT INTO books VALUES(2, "Persepolis", "Marjane Satrapi", 2005);
    ```

    컬럼명을 지정하면 입력하지 않은 값은 NULL로 처리된다.

    ```sql
    INSERT INTO books(title, writer) VALUES ("Autumn", "Ali Smith");
    ```

    ### 3. 데이터 불러오기

    데이터를 불러올 때는 SELECT문을 쓰는데 순서를 지켜야 한다.

    - 작성 순서

      > SELECT - FROM - WHERE - GROUP BY - HAVING - ORDER BY

    - 실행 순서

      > FROM - WHERE - GROUP BY - HAVING - SELECT - ORDER BY

    ### 1) SELECT

    가져오고 싶은 column명을 입력한다. column명은 변경이 가능하고, 기존에 없던 데이터를 추가할 수도 있다.

    ```sql
    SELECT '2005년' year, HOUR(datetime) HOUR, count(hour(datetime)) COUNT
    ```

    이 경우 year라는 컬럼이 기존에 없더라도 추가가 가능하며 '2005년'이라는 데이터가 일괄적으로 들어간다. 그리고 hour(datetime) 뒤에 넣고싶은 컬럼명을 설정하면(위에서는 HOUR) 된다. "HOUR" 이라고 큰따옴표를 넣어서 표시할 수도 있다.

    ### 2) FROM

    from 뒤에는 값을 가져오고 싶은 테이블 명을 입력한다

    ### 3) WHERE

    집계함수를 사용할 수 없다.

    - **필드 값이 있는지 확인하고 싶을 때** IS NULL, IS NOT NULL을 사용하면 된다.

    ```sql
    SELECT * FROM books WHERE released_year IS NULL;
    ```

    출판년도가 NULL인 데이터만 가져온다.

    ### 4) GROUP BY

    데이터를 그룹화해서 가져온다

    ### 5) HAVING

    group by절과 함께 사용되며, 집계함수로 조건비교를 할 수 있다.

    ### 6) ORDER BY

    데이터 정렬 기준. 여러개의 기준을 세울수도 있고, 역순으로 배열하는것도 가능하다.

    ------

    ### 기타

    - 집계함수 (count, max, min, sum, avg)

    ```sql
    SELECT sum(minutes) FROM todo_list;
    SELECT count(name) FROM animal_ins;
    ```

    말 그대로 합계나 최대, 최소값, 총합, 평균을 구할 수 있다.count의 경우 NULL값일 경우 총합에서 제외하지만 중복값은 제외하지 않는다. 이럴 경우 distinct를 활용하면 중복값을 제외한 총계를 얻을 수 있다.

    ```sql
    SELECT count(DISTINCT name) FROM animal_ins;
    ```

    - **DDL (데이터 정의 언어) :** 스키마 생성 및 수정에 사용되는 쿼리입니다. SQL의 일반적인 DDL 명령에는 CREATE, ALTER 및 DROP이 포함됩니다.
    - **DML (데이터 조작 언어) :** 이 쿼리는 데이터베이스에서 선택, 삽입, 업데이트 및 삭제 작업을 수행하는 데 사용됩니다. SQL의 일반적인 DML 명령은 SELECT, INSERT, UPDATE 및 DELETE입니다.
    - **DCL (데이터 제어 언어) :** 이러한 쿼리는 액세스를 제어하고 데이터베이스에 대한 권한을 제공하는 데 사용됩니다. SQL의 일반적인 DCL 명령은 GRANT 및 REVOKE입니다.
    - **TCL (트랜잭션 제어 언어) :** 이러한 쿼리는 데이터 무결성을 유지하기 위해 트랜잭션을 제어하고 관리하는 데 사용됩니다. SQL의 일반적인 TCL 명령에는 BEGIN, COMMIT 및 ROLLBACK이 포함됩니다.

  - 간단한 예제

  - where와 having의 차이

- DB의 join에 대해 설명

  - **답변**

    관계형 데이터베이스에서는 중복 데이터를 피하기 위해서 데이터를 쪼개 여러 테이블로 나눠서 저장합니다. 이렇게 분리되어 저장된 데이터에서 원하는 결과를 다시 도출하기 위해서는 여러 테이블을 조합할 필요가 있습니다. 관계형 데이터베이스에서는 조인(JOIN) 연산자를 사용해 관련 있는 칼럼 기준으로 행을 합쳐주는 연산입니다.

- 인덱스란 무엇인가?

  인덱스 정의, 내부적으로 B+tree로 구성, 어째서 SELECT 구문에서 효율적이고 UPDATE, DELETE 구문에서 비효율적인지 B+tree와 연관지어서 설명

  - **답변**

    **`인덱스(INDEX)`**는 **DBMS**의 검색 속도를 높이기 위한 기술입니다.

    **DBMS**는 데이터를 순차적으로 쌓으므로, 특정 데이터를 찾기 위해서는 데이터의 **FULL-SCAN**인 순차 탐색(**O(N)**)이 필요합니다.

    **DBMS**는 특정 데이터를 특별한 자료 구조로 쌓아 탐색 속도를 개선할 수 있는 기능을 제공합니다. 해당 기능을 **`인덱스`**라 부르고 쌓은 데이터들을 **`인덱스 테이블`**이라 부릅니다.

    인덱스는 책의 목차와 비유할 수 있습니다. 우리가 책의 목차를 참고하여 필요한 내용으로 곧 바로 넘어가듯이, **DBMS**도 **`인덱스 테이블`**에서 특정 **`인덱스`**를 찾아 필요한 행 데이터를 바로 가져옵니다.

    B+트리 구조를 사용하고 있으므로 조회보다 삽입, 삭제, 업데이트가 더 많이 발생하는 테이블은 인덱스 기능이 오히려 단점이 될 수 있습니다.

  - **추가**

    **TABLE**을 생성 할 때, **PRIMARY_KEY**를 지정한 컬럼은 자동적으로 **PRIMARY_KEY**를 기준으로 **`인덱스 테이블`**이 생성됩니다.

    만약 다른 컬럼을 **`인덱스 테이블`**을 생성하고 싶다면, 직접 생성해야 합니다.

    - **인덱스 장점**

      - 빠른 조회

      **`인덱스 테이블`**은 메모리에 저장되어 있는 **B+트리** 자료구조 입니다.

      메모리는 한정적인 자원이기 때문에 **DBMS**는 **`인덱스`**로 지정한 컬럼 데이터와 **ROW-ID**로 구성된 최소한의 노드로 **B+트리**를 구성합니다.

      > ROW-ID

      여기에서 알 수 있는 재미있는 특징이 하나 있습니다. 데이터 **FULL-SCAN**이 느린이유는 순차탐색인 이유도 있지만, 빈번한 **파일IO**도 많은 영향을 미칩니다.

      반면에 빠른 메모리 조회로 행 아이디를 찾는 **`인덱스`** 방식은 최소한의 **파일IO**를 사용합니다. 최소한의 **파일IO**는 더욱 빠른 탐색 속도를 가능하게 합니다.

      - 데이터 정렬

      만약 **`인덱스`**된 컬럼으로 정렬 명령을 내린다면 정렬 비용을 아낄 수 있습니다.

      **B+트리** 구조상 조회된 데이터를 가져오기만 해도 정렬된 데이터를 획득할 수 있기 때문입니다.

    - **인덱스 단점**

      - 인덱스 테이블 유지 비용

      **B+트리**의 중요한 특징 중 하나는 **균형 이진 트리**를 구성한다는 점 입니다. 노드의 삭제, 삽입시 트리 균형을 위해 트리 구조를 재구성 하는 비용이 발생합니다. 더군다나 탐색 이진 트리의 업데이트는 삭제 + 삽입 과정이 발생하므로 2배의 비용이 발생하게 됩니다.

      위에서 살펴본 B+트리의 특징이 인덱스 테이블에도 똑같이 적용됩니다.

      즉, O(log_2﻿)으로 빠르게 조회가 가능하지만 삽입, 삭제, 업데이트 작업은 ***노드의 위치 탐색 비용\*** + ***트리 재구성 비용\*** 이 발생하게 됩니다.

      **DBMS**는 트리 재구성 비용이라도 아끼기 위해 노드 삭제를 진행하지 않습니다. 대신 해당 노드에 사용하지 않는다는 마킹만 진행합니다. 그로인해 **DBMS**의 삭제, 업데이트 명령은 노드의 위치 탐색 비용만 발생하게 됩니다.

      - 인덱스 테이블 추가 공간 비용

      **`인덱스 테이블`**의 노드 삭제를 하지 않음으로써, 트리 재구성 비용을 아낀 전략은 유효해 보입니다. 하지만 이 역시도 다른 문제가 존재합니다.

      그 문제는 바로, **`인덱스 테이블`**이 거대해짐에 따라, 트리의 높이가 깊어지는 문제 입니다.

      이는 테이블의 행 개수 보다 많은 개수의 저장공간을 필요로 합니다.

      하지만 더욱 결정적인 문제는 트리 높이에 따른 성능으로 인해 **`인덱스 테이블`** 의 깊은 높이는 **DBMS** 성능을 점진적으로 내린다는 점 입니다.

      결론적으로, 미 사용 노드를 트리에서 제거함으로써 높이 최적화가 필요함 을 알 수 있습니다. **DBMS**는 트리 높이 최적화를 수행하는 명령을 제공합니다. 해당 명령을 주기적으로 수행함으로써 전체적인 **DBMS** 성능을 높일 수 있습니다.

- 파티셔닝이란 무엇인가?

  - **답변**

    서비스의 크기가 점점 커지고 DB에 저장하는 데이터의 규모 또한 대용량화 되면서, 기존에 사용하는 DB 시스템의 용량의 한계와 성능의 저하를 가져오게 되었다. 이런 이슈를 해결하기 위한 방법으로 테이블을 파티션이라는 작은 단위로 나누어 관리하는 파티셔닝 기법이 나타나게 되었다.

    물리적인 데이터 분할이 있더라도, DB에 접근하는 application의 입장에서는 이를 인식하지 못한다.

  - **파티셔닝의 이점**

    가용성(Availability)

    - 물리적인 Partitioning으로 인해 전체 데이터의 훼손 가능성이 줄어들고 데이터 가용성이 향상된다.

    관리용이성(Manageability)

    - 큰 Table들을 제거하여 관리를 쉽게 해준다.

    성능(Performance)

    - 특정 DML과 Query의 성능을 향상시킴, 주로 대용량 Data Write 환경에서 효율적이다.
    - 많은 Insert가 있는 OLTP 시스템에서 Insert 작업들을 분리된 파티션들로 분산시켜 경합을 줄인다.

  - **파티셔닝의 단점**

    - Table간의 Join에 대한 비용이 증가한다.
    - 테이블과 인덱스를 별도로 파티션 할수는 없다. 테이블과 인덱스를 같이 Partitioning 하여야 한다.

  - **파티셔닝의 종류**

    - 수평 파티셔닝

      ![https://gmlwjd9405.github.io/images/database/horizontal-partitioning.png](https://gmlwjd9405.github.io/images/database/horizontal-partitioning.png)

      하나의 테이블의 각 행을 다른 테이블에 분산시키는 것이다

      같은 주민 데이터를 처리하기 위해 스키마가 같은 ‘서현동주민 테이블’과 ‘정자동주민 테이블’을 사용하는 것을 말한다. 인덱스의 크기를 줄이고, 작업 동시성을 늘리기 위한 것이다.

    - 수직 파티셔닝

      ![https://gmlwjd9405.github.io/images/database/vertical-partitioning.png](https://gmlwjd9405.github.io/images/database/vertical-partitioning.png)

      테이블의 일부 열을 빼내는 형태로 분할한다.

      - 특징 관계형 DB에서 3정규화와 같은 개념으로 접근하면 이해하기 쉽다. 하지만 수직 파티셔닝은 이미 정규화된 데이터를 분리하는 과정이다.
      - 예시 한 고객은 하나의 청구 주소를 가지고 있을 수 있다. 그러나 데이터의 유연성을 위해 다른 데이터베이스로 정보를 이동하거나 보안의 이슈 등을 이유로 CustomerId를 참조하도록 하고 청구 주소 정보를 다른 테이블로 분리할 수 있다.

  - 분할 기준

    1. 범위 분할 (range partitioning) 분할 키 값이 범위 내에 있는지 여부로 구분한다. 예를 들어, 우편 번호를 분할 키로 수평 분할하는 경우이다.
    2. 목록 분할 (list partitioning) 값 목록에 파티션을 할당 분할 키 값을 그 목록에 비추어 파티션을 선택한다. 예를 들어, Country 라는 컬럼의 값이 Iceland , Norway , Sweden , Finland , Denmark 중 하나에 있는 행을 빼낼 때 북유럽 국가 파티션을 구축 할 수 있다.
    3. 해시 분할 (hash partitioning) 해시 함수의 값에 따라 파티션에 포함할지 여부를 결정한다. 예를 들어, 4개의 파티션으로 분할하는 경우 해시 함수는 0-3의 정수를 돌려준다.

- 트랜잭션이란 무엇인가?

  - **답변**

    트랜잭션이란 데이터베이스의 상태를 변화시키기 위해서 수행하는 작업의 단위를 뜻합니다.

    예를 들어 유저가 포인트로 다른 유저가 등록한 상품을 구매한다고 했을 때 거래가 성공적으로 처리됐을 경우에만 구매한 유저의 포인트를 차감하고 판매한 유저의 포인트를 증가 시켜주어야 합니다.

    만약 구매 유저의 포인트가 부족해서 거래가 정상적으로 이루어지지 않았는데 판매 유저의 포인트를 증가시키는 일이 발생할 수 있으므로 (데이터의 무결성을 무너뜨리게 됨) DB의 상태를 변화시키는 일련의 주문 과정을 하나의 작업 단위로 처리해야 합니다.

    - 원자성 (Atomicity)

      원자성은 트랜잭션이 데이터베이스에 모두 반영되던가, 아니면 전혀 반영되지 않아야 한다는 것

      이다.

    - 일관성 (Consistency)

      일관성은 트랜잭션의 작업 처리 결과가 항상 일관성이 있어야 한다는 것이다.

      트랜잭션이 진행되는 동안에 데이터베이스가 변경 되더라도 업데이트된 데이터베이스로 트랜잭션이 진행되는것이 아니라,

      처음에 트랜잭션을 진행 하기 위해 참조한 데이터베이스로 진행된다. 이렇게 함으로써 각 사용자는 일관성 있는 데이터를 볼 수 있는 것이다.

    - 독립성 (Isolation)

      독립성은 둘 이상의 트랜잭션이 동시에 실행되고 있을 경우 어떤 하나의 트랜잭션이라도, 다른 트랜잭션의 연산에 끼어들 수 없다는 점을 가리킨다.

      하나의 특정 트랜잭션이 완료될때까지, 다른 트랜잭션이 특정 트랜잭션의 결과를 참조할 수 없다.

    - 지속성 (Durability)

      지속성은 트랜잭션이 성공적으로 완료되었을 경우, 그 결과는 영구적으로 반영되어야 한다는 것이다.

- POLYGON, POINT 데이터타입에 대한 설명

  - **답변**

    폴리곤과 포인트등은 X, Y 좌표로 구성된 공간 데이터 타입으로, 포인트는 좌표 공간에서 한 지점의 위치를 표시하고 폴리곤은 다수의 선분들의 연결되어 닫혀 있는 상태의 다각형입니다. 폴리곤을 생성할 때는 맨 처음 좌표와 마지막 좌표의 값이 같아야 합니다. 이와 같은 공간 데이터들을 활용하여 위치 기반 서비스를 구현할 수 있습니다.

    일반적으로 사용하고 있는 RDBMS인 Oracle, MariaDB, MySQL, PostgreSQL 등에서 공간 데이터를 처리하기 위한 spatialDB를 제공하고 있습니다.

- 스키마란?

  **1.** 스키마는 데이터베이스의 구조와 제약 조건에 관한 전반적인 명세를 기술한 메타데이터의 집합이다.

  **2.** 스키마는 데이터베이스를 구성하는 데이터 개체(Entity), 속성(Attribute), 관계(Relationship) 및 데이터 조작 시 데이터 값들이 갖는 제약 조건 등에 관해 전반적으로 정의한다.

  **3.** 스키마는 사용자의 관점에 따라 외부 스키마, 개념 스키마, 내부 스키마로 나눠진다.

  **스키마의 특징**

  **1.** 스키마는 데이터 사전(Data Dictionary)에 저장되며, 다른 이름으로 메타데이터라고도 한다.

  **2.** 스키마는 현실 세계의 특정한 한 부분의 표현으로서 특정 데이터 모델을 이용해서 만들어진다.

  **3.** 스키마는 시간에 따라 불변인 특성을 갖는다.

  **4.** 스키마는 데이터의 구조적 특성을 의미하며, 인스턴스에 의해 규정된다.

- 일대다, 다대다(one to many, many to many) 관계에 대한 설명

  - 답변

    - **일대다**

      **`1:N 관계`**는 한 쪽 엔티티가 **관계를 맺은 엔티티 쪽의 여러 객체를 가질 수 있는 것**을 의미한다.

      예를 들어, 하나의 카테고리에 여러 상품이 속해있는 관계를 생각해보면, 카테고리는 여러 상품을 가질 수 있지만 상품들은 하나의 카테고리에 속한다. *이를 카테고리가 상품을 소유한다고(has a 관계) 표현한다.*

      이러한 관계를 `1:N 관계`라고 하며, 계층적인 구조로 이해할 수도 있다.

      PK, FK란?

      *`PK(Primary Key)` : 각 엔티티를 식별할 수 있는 대표키, 테이블에서 중복되지 않는(Unique) 값, Null일 수 없다.*

      *`FK(Foreign Key` : 다른 테이블의 기본키를 참조, 모든 필드는 참조하는 기본키와 동일한 도메인(값의 종류&범위)을 갖는다.모든 필드 값은 참조하는 기본키와 동일하거나 null 일 수 있다.*

    - **다대다**

      **`N:M 관계`**는 관계를 가진 **양쪽 엔티티 모두에서 `1:N 관계`를 가지는 것**을 말한다.

      즉, **서로가 서로를 `1:N 관계`로 보고 있는 것**이다.

      예를들어, 학원과 학생의 관계를 생각해보면, 한 학원에는 여러명의 학생이 수강할 수 있으므로 `1:N 관계`를 가진다.

      반대로 학생도 여러개의 학원을 수강할 수 있으므로, 이 사이에서도 `1:M 관계`를 가진다.

      `N:M 관계`는 서로가 서로를 `1:N 관계`, `1:M 관계`로 갖고 있기 때문에, **서로의 `PK`를 자신의 외래키 컬럼으로 갖고 있으면 된다.**

      일반적으로 **`N:M 관계`는 두 테이블의 대표키를 컬럼으로 갖는 또 다른 테이블을 생성해서 관리한다.**

- PK를 구분 하는 이유

  - **답변**

    PK는 테이블에서 오직 한개만 존재할 수 있으며, 이 PK는 테이블에서 데이터의 유일성을 보장해 줍니다.

    PK의 구성은 B*tree Index, Unique, Not Null의 구조를 가지고 있습니다.

    기본키가 없으면 일관성 없는 데이터가 반복적으로 쌓일 수 있기 때문에 쿼리 속도가 느리고, 원하지 않는 정보 조회 결과를 가져올 수 있습니다. 관계형 데이터베이스에서는 반드시 각 행이 고유하게 식별되어야 합니다. 이 규칙을 위반하면 더 이상 관계형이 아니며 데이터에서 모호함이 생길 수 있습니다. 대부분의 경우에 PK값을 기반으로 테이블의 행을 검색하거나 FK값으로 활용하여 다른 테이블과 결합합니다.

- 데이터베이스를 다룰 때 가장 자신있는 것

  - 답변

    프로젝트에서 MySQL을 가장 많이 사용했기 때문에 MySQL에 제일 익숙하고, 관계형 DB 모델링부터  django ORM을 활용해 업로더 파일을 생성해 프로젝트에 필요한 데이터를 생성하거나 AWS RDS DB에 로컬에서 구축해놓은 DB를 dump하는 과정까지 여러 번 경험해보았기 때문에 프로젝트에서 데이터베이스의 중요성과 필요한 작업들이 어떤 것인지 전체적인 플로우를 이해하고 있습니다.

- ERD 툴 어떤 것을 사용했는지? 짜는 과정에서 어려웠던 점?

  - **답변**

    aquerytool과 erdcloud를 사용해보았습니다. 모델링 개념을 처음 접했을 때는, 필요한 데이터들을 2차원 테이블로 담는다는 개념과 서로의 관계를 정의내리는 과정이 어렵게 느껴졌지만 단순한 모델링으로 시작해서 좀 더 복잡한 모델링까지 직접 해보면서 처음보다 훨씬 익숙해졌습니다.

- 프로그래밍에서 로직/데이터베이스 무엇이 중요한가?

  - **답변**

    데이터베이스는 프로그램에 필요한 모든 데이터들을 영속적으로 보관하는 저장매체이고 로직은 데이터들의 조작과 처리라고 정의했을 때, 둘 중에 어느 것이 더 중요하다고 말하기 보다 데이터베이스는 어떤 결과물을 내기 위한 재료이고 로직은 그 재료들을 실제 결과물로 만들어내는 가공 과정이라고 볼 수 있을 것 같습니다.

    만약 로직을 아무리 잘 짜는 사람이라고 해도 DB의 모델이 잘못 설계 되어있거나 서비스의 특성에 맞지 않는 DB를 사용중이라고 하면 서비스의 성능을 보장할 수 없고 로직을 설계하기도 훨씬 복잡해질 것입니다. 반대로 서비스에 맞게 DB가 구축되어있다고 해도 로직을 짜는 사람이 DB의 특성을 이해하지 못하고 최적화를 고려하지 않은 로직을 짠다고 하면 서비스에 맞게 설계된 DB의 효율을 발휘하지 못하게 될 것입니다.